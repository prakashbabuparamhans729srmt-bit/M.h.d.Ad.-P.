/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model for all
 * private data, ensuring that users can only access their own information. Publicly
 * accessible content is globally readable but has tightly controlled write access.
 * An admin role, identified by a specific email, has broader read access for oversight.
 *
 * Data Structure: User-specific data is hierarchically organized under the /users/{userId}
 * path. Public content resides in top-level collections like /blogPosts.
 *
 * Key Security Decisions:
 * - User Enumeration is disallowed for regular users.
 * - An admin (admin@example.com) is allowed to list all users for management purposes.
 * - All data within a user's path (/users/{userId}/...) is private to that user, with admin read-only override.
 *
 * Denormalization for Authorization: The rules rely on path-based authorization
 * (e.g., matching {userId} in the path to the authenticated user's UID) to avoid
 * costly and slow `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    // --------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Admin Check - Simplified and direct for clarity
    function isAdmin() {
        return request.auth.token.email == 'admin@example.com';
    }


    // Collection Rules
    // --------------------------------

    // Rule for individual user document access
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) || isAdmin();
      allow delete: if isOwner(userId) || isAdmin();

      // Nested collections for a user
      match /projects/{projectId} {
        allow get, list: if isOwner(userId) || isAdmin();
        allow create: if isOwner(userId) && request.resource.data.clientId == userId;
        allow update, delete: if isOwner(userId) || isAdmin();

        match /files/{fileId} {
          allow get, list: if isOwner(userId) || isAdmin();
          allow create: if isOwner(userId);
          allow update, delete: if isOwner(userId) || isAdmin();
        }

        match /timelineSummaries/{timelineSummaryId} {
          allow get, list: if isOwner(userId) || isAdmin();
          allow create: if isOwner(userId);
          allow update, delete: if isOwner(userId) || isAdmin();
        }
      }
    }
    
    // Explicit rule for LISTING the entire users collection.
    // THIS IS THE CRITICAL FIX: Only the admin can list all users.
    match /users/{document=**} {
      allow list: if isAdmin();
    }

    // Explicit rule for Collection Group Queries by Admin
    match /{path=**}/projects/{projectId} {
        allow get, list: if isAdmin();
    }


    // Public collections
    match /blogPosts/{blogPostId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if (resource != null && isOwner(resource.data.authorId)) || isAdmin();
      allow delete: if (resource != null && isOwner(resource.data.authorId)) || isAdmin();
    }

    match /landingPages/{landingPageId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }
  }
}
